@using Zonit.Extensions.Cultures
@using Zonit.Extensions.Organizations
@using Zonit.Messaging.Tasks

@using Zonit.Services.Dashboard.Data

@namespace Zonit.Services.Dashboard.Areas.Dashboard.Components

@inject ICultureProvider Culture
@inject IWorkspaceProvider Workspace
@inject IExtensionManager ExtensionManager
@inject ITaskManager TaskManager
@implements IAsyncDisposable

<MudChip T="string"
         Label="true"
         Icon="@IconData.TaskIcon"
         Color="@(HasProcessingTasks ? Color.Warning : Color.Default)"
         OnClick="@(() => ExtensionManager.Drawer(ExtensionName).Toggle())"
         Size="Size.Medium"
         Variant="Variant.Outlined"
         Class="mx-1 my-1">

    <div class="d-flex align-center" style="gap: 6px;">
        @ActiveTasks.Count
    </div>
</MudChip>


@code {
static readonly string ExtensionName = Extensions.Task;
private Timer? _refreshTimer;
private bool _disposed = false;
private IDisposable? _taskSubscription;

    private IReadOnlyCollection<TaskState> ActiveTasks { get; set; } = [];
    private bool HasProcessingTasks => ActiveTasks.Any(t => t.Status == Zonit.Messaging.Tasks.TaskStatus.Processing);
    private bool HasFailedTasks => ActiveTasks.Any(t => t.Status == Zonit.Messaging.Tasks.TaskStatus.Failed);

    protected override void OnInitialized()
    {
        Culture.OnChange += StateHasChanged;
        Workspace.OnChange += StateHasChanged;
        ExtensionManager.Drawer(ExtensionName)
            .OnChange += StateHasChanged;

        // Timer dla animacji pulsowania
        _refreshTimer = new Timer(OnTimerCallback, null, TimeSpan.Zero, TimeSpan.FromSeconds(1));

        ActiveTasks = TaskManager.GetActiveTasks(Workspace.Organization?.Id);
        
        // Subscribe to task changes
        if (Workspace.Organization?.Id != null)
        {
            _taskSubscription = TaskManager.OnChange(Workspace.Organization.Id, task =>
            {
                if (_disposed) return;
                
                ActiveTasks = TaskManager.GetActiveTasks(Workspace.Organization.Id);
                
                try
                {
                    InvokeAsync(StateHasChanged);
                }
                catch (ObjectDisposedException)
                {
                    // Component has been disposed, ignore
                }
                catch (InvalidOperationException)
                {
                    // Component is no longer in the render tree, ignore
                }
            });
        }
        else
        {
            _taskSubscription = TaskManager.OnChange(task =>
            {
                if (_disposed) return;
                
                ActiveTasks = TaskManager.GetActiveTasks();
                
                try
                {
                    InvokeAsync(StateHasChanged);
                }
                catch (ObjectDisposedException)
                {
                    // Component has been disposed, ignore
                }
                catch (InvalidOperationException)
                {
                    // Component is no longer in the render tree, ignore
                }
            });
        }
    }

    private async void OnTimerCallback(object? state)
    {
        if (_disposed) return;
        
        try
        {
            await InvokeAsync(StateHasChanged);
        }
        catch (ObjectDisposedException)
        {
            // Component has been disposed, stop the timer
            _refreshTimer?.Dispose();
        }
        catch (InvalidOperationException)
        {
            // Component is no longer in the render tree, stop the timer
            _refreshTimer?.Dispose();
        }
        catch (Exception)
        {
            // Any other exception during rendering, stop the timer to prevent crashes
            _refreshTimer?.Dispose();
        }
    }

    private Color GetBadgeColor()
    {
        if (HasFailedTasks) return Color.Error;
        if (HasProcessingTasks) return Color.Warning;
        if (ActiveTasks.Any()) return Color.Default;
        return Color.Default;
    }

    private Color GetButtonColor()
    {
        if (HasFailedTasks) return Color.Error;
        if (HasProcessingTasks) return Color.Warning;
        if (ActiveTasks.Any()) return Color.Default;
        return Color.Default;
    }

    public async ValueTask DisposeAsync()
    {
        _disposed = true;
        
        Culture.OnChange -= StateHasChanged;
        Workspace.OnChange -= StateHasChanged;
        ExtensionManager.Drawer(ExtensionName)
            .OnChange -= StateHasChanged;
            
        _taskSubscription?.Dispose();
        _taskSubscription = null;
            
        if (_refreshTimer != null)
        {
            await _refreshTimer.DisposeAsync();
            _refreshTimer = null;
        }
    }
}