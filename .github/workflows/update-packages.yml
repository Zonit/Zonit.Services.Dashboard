name: Update NuGet Packages

on:
  workflow_dispatch:

jobs:
  update-packages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Fail if not on master
        if: github.ref != 'refs/heads/master'
        run: |
          echo "This workflow must run only on master branch!"
          exit 1

      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Setup .NET 6 to 10 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x
            9.0.x
            10.0.x

      - name: Install dotnet-outdated tool
        run: dotnet tool install --global dotnet-outdated-tool

      - name: Find solution file
        id: find-sln
        run: |
          slnfile=$(find . -maxdepth 1 -name '*.sln' | head -n 1)
          if [[ -z "$slnfile" ]]; then
            echo "No solution file found!"
            exit 1
          fi
          echo "sln=$slnfile" >> $GITHUB_OUTPUT

      - name: Update packages using dotnet-outdated
        run: |
          dotnet outdated "${{ steps.find-sln.outputs.sln }}" --upgrade --no-restore | tee outdated.log

      - name: Update conditional package versions in Directory.Packages.props and .csproj
        shell: pwsh
        run: |
            function Get-LatestMajorNuGetVersion {
                param (
                    [string]$PackageId,
                    [string]$MajorVersion
                )
                $LowerBound = "$MajorVersion."
                $url = "https://api.nuget.org/v3-flatcontainer/$($PackageId.ToLower())/index.json"
                try {
                    $response = Invoke-RestMethod -UseBasicParsing -Uri $url -ErrorAction Stop
                    if ($response.versions) {
                        $matching = $response.versions | Where-Object { $_ -like "$LowerBound*" }
                        if ($matching) {
                            return $matching[-1]
                        }
                    }
                } catch {
                    Write-Warning "  Problem downloading info for $PackageId ($url)"
                }
                return $null
            }

            function Update-Packages-InFile {
                param(
                    [string]$FilePath
                )

                Write-Host "`nChecking $FilePath" -ForegroundColor Cyan
                try {
                    [xml]$xml = Get-Content $FilePath
                } catch {
                    Write-Warning "$FilePath is not a valid XML file, skipping."
                    return
                }

                $modified = $false
                $chg = @()

                if ($FilePath -like "*Directory.Packages.props") {
                    foreach ($itemGroup in $xml.Project.ItemGroup) {
                        foreach ($pkg in $itemGroup.PackageVersion) {
                            $pkgId   = $pkg.Include
                            $currVer = $pkg.Version
                            if ($currVer -match '^(\d+)\.') {
                                $major = $matches[1]
                            } else {
                                $major = 8 # fallback
                            }
                            $latest = Get-LatestMajorNuGetVersion -PackageId $pkgId -MajorVersion $major
                            if ($latest -and $latest -ne $currVer) {
                                Write-Host ("  Updating {0} ({1} -> {2})" -f $pkgId,$currVer,$latest) -ForegroundColor Yellow
                                $pkg.SetAttribute("Version", "$latest")
                                $modified = $true
                                $chg += "$pkgId : $currVer -> $latest"
                            } else {
                                Write-Host ("  {0} already up to date ({1})" -f $pkgId,$currVer) -ForegroundColor Gray
                            }
                        }
                    }
                }
                elseif ($FilePath -like "*.csproj") {
                    $itemGroups = $xml.Project.ItemGroup | Where-Object { $_.Condition -match "TargetFramework" }
                    foreach ($group in $itemGroups) {
                        if ($group.Condition -match "'\$\((TargetFramework)\)'\s*==\s*'(?<tf>[a-zA-Z0-9\.]+)'") {
                            $tf = $matches['tf']
                            if ($tf -match "^net(?<major>\d+)\.0$") {
                                $major = $matches['major']
                            } else {
                                continue
                            }
                            $packageItems = $group.PackageVersion
                            foreach ($pkg in $packageItems) {
                                $pkgId   = $pkg.Include
                                $currVer = $pkg.Version
                                if (-not $pkgId -or -not $currVer) { continue }
                                $latest = Get-LatestMajorNuGetVersion -PackageId $pkgId -MajorVersion $major
                                if ($latest -and $latest -ne $currVer) {
                                    Write-Host ("  Updating {0} ({1} -> {2})" -f $pkgId,$currVer,$latest) -ForegroundColor Yellow
                                    $pkg.SetAttribute("Version", "$latest")
                                    $modified = $true
                                    $chg += "$pkgId : $currVer -> $latest"
                                } else {
                                    Write-Host ("  {0} already up to date ({1})" -f $pkgId,$currVer) -ForegroundColor Gray
                                }
                            }
                        }
                    }
                }
                else {
                    Write-Host "  Skipped - not relevant type" -ForegroundColor DarkGray
                    return
                }

                if ($modified) {
                    $xml.Save($FilePath)
                    Write-Host "  Saved $FilePath" -ForegroundColor Green
                    return ,$chg
                } else {
                    Write-Host "  No changes in $FilePath"
                    return @()
                }
            }

            # Użyj bieżącego katalogu jako root
            $files = Get-ChildItem -Path "." -Recurse -Include "Directory.Packages.props","*.csproj" -File
            $allChg = @()
            foreach ($file in $files) {
                $result = Update-Packages-InFile -FilePath $file.FullName
                if ($result) {
                    $allChg += $result
                }
            }

            if ($allChg.Count -gt 0) {
                Set-Content -Path conditional-updates.log -Value ($allChg -join "`n")
            } else {
                Set-Content -Path conditional-updates.log -Value ""
            }

            Write-Host "`nCompleted full scan!" -ForegroundColor Magenta

      - name: Check for changes
        id: git-check
        run: |
          if [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Ensure "automated-task" label exists
        if: steps.git-check.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh_label_exists=$(gh api repos/${{ github.repository }}/labels/automated-task --silent 2>/dev/null || echo "404")
          if [[ "$gh_label_exists" == "404" ]]; then
            gh api repos/${{ github.repository }}/labels \
              -X POST \
              -F name='automated-task' \
              -F color='ededed' \
              -F description='PR generated by NuGet update workflow'
          fi

      - name: Prepare PR body with list of updated packages
        id: pr-body
        if: steps.git-check.outputs.changed == 'true'
        run: |
          changes=$(grep -E ' -> ' outdated.log | grep -vE '^\s*$|^\[' | awk '{$1=$1};1' | sort | uniq)
          cond_changes=$(cat conditional-updates.log)
          BODY=""
          
          if [[ -n "$changes" ]]; then
              BODY="### The following NuGet packages were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk '{print $1}')
                  from=$(echo "$line" | awk '{print $2}')
                  to=$(echo "$line" | awk '{print $4}')
                  BODY+="
          - **$name**: \`$from\` ~~→~~ \`$to\`"
              done <<< "$changes"
          fi
          
          if [[ -n "$cond_changes" ]]; then
              BODY+="
          ### The following conditional NuGet package versions were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk -F':' '{print $1}')
                  fromto=$(echo "$line" | awk -F':' '{print $2}')
                  BODY+="
          - **$name**: $fromto"
              done <<< "$cond_changes"
          fi
          
          if [[ -z "$BODY" ]]; then
              BODY="NuGet run did not output package updates, but there are file changes."
          fi
          
          BODY="${BODY//'%'/'%25'}"
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.git-check.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          title: "[Task] Automated NuGet package update"
          commit-message: "[Task] Automated NuGet package update"
          branch: auto/update-nuget-packages
          base: master
          delete-branch: true
          labels: automated-task
          body: ${{ steps.pr-body.outputs.body }}