name: Update NuGet Packages

on:
  workflow_dispatch:

jobs:
  update-packages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Fail if not on master
        if: github.ref != 'refs/heads/master'
        run: |
          echo "This workflow must run only on master branch!"
          exit 1

      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Setup .NET 6 to 10 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x
            9.0.x
            10.0.x

      - name: Install dotnet-outdated tool
        run: dotnet tool install --global dotnet-outdated-tool

      - name: Find solution file
        id: find-sln
        run: |
          slnfile=$(find . -maxdepth 1 -name '*.sln' | head -n 1)
          if [[ -z "$slnfile" ]]; then
            echo "No solution file found!"
            exit 1
          fi
          echo "sln=$slnfile" >> $GITHUB_OUTPUT

      - name: Update packages using dotnet-outdated
        run: |
          dotnet outdated "${{ steps.find-sln.outputs.sln }}" --upgrade --no-restore | tee outdated.log

      - name: Update conditional package versions in Directory.Packages.props
        shell: pwsh
        run: |
            $propsPath = "Source/Directory.Packages.props"
            if (!(Test-Path $propsPath)) {
              Write-Host "Directory.Packages.props file not found at $propsPath, skipping step."
              exit 0
            }

            [xml]$props = Get-Content $propsPath

            # Identify .NET versions used in the project
            $usedNetVersions = @()
            foreach ($itemGroup in $props.Project.ItemGroup) {
              if ($itemGroup.Condition) {
                if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                  $usedNetVersions += $Matches[1]
                }
              }
            }

            Write-Host "Detected .NET versions: $($usedNetVersions -join ', ')"

            function IsPreviewVersion {
              param([string]$version)
              return $version -match "-(preview|rc|alpha|beta)"
            }

            function GetVersionParts {
              param([string]$version)
  
              $result = @{
                IsPreview = IsPreviewVersion $version
                Major = 0
                Minor = 0
                Build = 0
                PreviewMajor = 0
                PreviewMinor = 0
                OriginalString = $version
              }
  
              # Handle preview versions with format like "10.0.0-preview.1.25080.5"
              if ($version -match "^(\d+)\.(\d+)\.(\d+)(?:-preview\.(\d+)(?:\.(\d+))?)?$") {
                $result.Major = [int]$Matches[1]
                $result.Minor = [int]$Matches[2]
                $result.Build = [int]$Matches[3]
    
                if ($Matches[4]) {
                  $result.PreviewMajor = [int]$Matches[4]
                  if ($Matches[5]) {
                    $result.PreviewMinor = [int]$Matches[5]
                  }
                }
    
                return $result
              }
  
              # Try standard System.Version parsing as fallback
              try {
                $v = [version]($version -replace '-.*$', '') # Remove preview suffix if any
                $result.Major = $v.Major
                $result.Minor = $v.Minor
                $result.Build = $v.Build
                return $result
              }
              catch {
                Write-Host "Unsupported version format: $version"
                return $result
              }
            }

            function CompareVersions {
              param(
                [string]$version1,
                [string]$version2
              )
  
              $v1 = GetVersionParts $version1
              $v2 = GetVersionParts $version2
  
              # First compare main versions
              if ($v1.Major -ne $v2.Major) { return $v1.Major.CompareTo($v2.Major) }
              if ($v1.Minor -ne $v2.Minor) { return $v1.Minor.CompareTo($v2.Minor) }
              if ($v1.Build -ne $v2.Build) { return $v1.Build.CompareTo($v2.Build) }
  
              # Non-preview versions are always higher than preview versions
              if (!$v1.IsPreview -and $v2.IsPreview) { return 1 }
              if ($v1.IsPreview -and !$v2.IsPreview) { return -1 }
  
              # Compare preview versions
              if ($v1.PreviewMajor -ne $v2.PreviewMajor) { return $v1.PreviewMajor.CompareTo($v2.PreviewMajor) }
              return $v1.PreviewMinor.CompareTo($v2.PreviewMinor)
            }

            function Get-LatestNugetVersionForMajor {
              param(
                [string]$packageId,
                [int]$netMajor,
                [string]$currentVersion
              )
  
              $url = "https://api.nuget.org/v3-flatcontainer/$packageId/index.json"
              try {
                $resp = Invoke-RestMethod -Uri $url -UseBasicParsing
    
                $isCurrentPreview = IsPreviewVersion $currentVersion
                $currentVersionParts = GetVersionParts $currentVersion
    
                # Only consider versions compatible with the target .NET version
                $compatibleVersions = @()
                foreach ($version in $resp.versions) {
                  $versionParts = GetVersionParts $version
      
                  # For Microsoft packages, major version should match the .NET target version
                  # especially for core components like ASP.NET Core and Extensions
                  if ($packageId -like "Microsoft.AspNetCore.*" -or 
                      $packageId -like "Microsoft.Extensions.*" -or 
                      $packageId -like "Microsoft.JSInterop") {
                    # Major version should match the .NET version
                    if ($versionParts.Major -ne $netMajor) {
                      continue
                    }
                  }
      
                  # Must be same stability type (preview or stable)
                  if ($isCurrentPreview -ne (IsPreviewVersion $version)) {
                    continue
                  }
      
                  $compatibleVersions += $version
                }
    
                if ($compatibleVersions.Count -eq 0) {
                  Write-Host "No compatible versions found for $packageId. Keeping current version."
                  return $currentVersion
                }
    
                # Sort versions using our custom comparison function
                $latestVersion = $null
                $highestCompare = -1
    
                foreach ($ver in $compatibleVersions) {
                  $compareResult = CompareVersions $ver $currentVersion
                  if ($compareResult -gt $highestCompare) {
                    $highestCompare = $compareResult
                    $latestVersion = $ver
                  }
                }
    
                if ($highestCompare -gt 0 -and $latestVersion) {
                  Write-Host "Found newer version for $packageId - $latestVersion (current: $currentVersion)"
                  return $latestVersion
                } else {
                  Write-Host "No newer version found for $packageId (current: $currentVersion)"
                  return $currentVersion
                }
              }
              catch {
                $errorMessage = $_.Exception.Message
                Write-Host "Error retrieving versions for $packageId - $errorMessage"
                return $currentVersion
              }
            }

            $changes = @()
            $supportedMajors = @(6, 7, 8, 9, 10)

            foreach ($itemGroup in $props.Project.ItemGroup) {
              if ($itemGroup.Condition) {
                if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                  $netMajor = [int]$Matches[1]
      
                  if ($supportedMajors -contains $netMajor) {
                    Write-Host "Processing packages for .NET $netMajor..."
        
                    foreach ($pkg in $itemGroup.PackageVersion) {
                      $id = $pkg.Include
                      $current = $pkg.Version
          
                      # Update only to versions compatible with the same framework
                      $latest = Get-LatestNugetVersionForMajor -packageId $id -netMajor $netMajor -currentVersion $current
          
                      if ($latest -and $current -ne $latest) {
                        Write-Host "Updating $id (net$netMajor.0): $current -> $latest"
                        $pkg.Version = $latest
                        $changes += "$id (net$netMajor.0): $current -> $latest"
                      }
                    }
                  } else {
                    Write-Host "Skipped unsupported .NET version $netMajor"
                  }
                }
              }
            }

            if ($changes.Count -gt 0) {
              $props.Save($propsPath)
              Set-Content -Path conditional-updates.log -Value ($changes -join "`n")
              Write-Host "Updated conditional package versions."
            } else {
              Write-Host "No changes to conditional package versions."
              Set-Content -Path conditional-updates.log -Value ""
            }

      - name: Check for changes
        id: git-check
        run: |
          if [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Ensure "automated-task" label exists
        if: steps.git-check.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh_label_exists=$(gh api repos/${{ github.repository }}/labels/automated-task --silent 2>/dev/null || echo "404")
          if [[ "$gh_label_exists" == "404" ]]; then
            gh api repos/${{ github.repository }}/labels \
              -X POST \
              -F name='automated-task' \
              -F color='ededed' \
              -F description='PR generated by NuGet update workflow'
          fi

      - name: Prepare PR body with list of updated packages
        id: pr-body
        if: steps.git-check.outputs.changed == 'true'
        run: |
          changes=$(grep -E ' -> ' outdated.log | grep -vE '^\s*$|^\[' | awk '{$1=$1};1' | sort | uniq)
          cond_changes=$(cat conditional-updates.log)
          BODY=""
          
          if [[ -n "$changes" ]]; then
              BODY="### The following NuGet packages were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk '{print $1}')
                  from=$(echo "$line" | awk '{print $2}')
                  to=$(echo "$line" | awk '{print $4}')
                  BODY+="
          - **$name**: \`$from\` ~~→~~ \`$to\`"
              done <<< "$changes"
          fi
          
          if [[ -n "$cond_changes" ]]; then
              BODY+="
          ### The following conditional NuGet package versions were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk -F':' '{print $1}')
                  fromto=$(echo "$line" | awk -F':' '{print $2}')
                  BODY+="
          - **$name**: $fromto"
              done <<< "$cond_changes"
          fi
          
          if [[ -z "$BODY" ]]; then
              BODY="NuGet run did not output package updates, but there are file changes."
          fi
          
          BODY="${BODY//'%'/'%25'}"
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.git-check.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          title: "[Task] Automated NuGet package update"
          commit-message: "[Task] Automated NuGet package update"
          branch: auto/update-nuget-packages
          base: master
          delete-branch: true
          labels: automated-task
          body: ${{ steps.pr-body.outputs.body }}