name: Update NuGet Packages

on:
  workflow_dispatch:

jobs:
  update-packages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Fail if not on master
        if: github.ref != 'refs/heads/master'
        run: |
          echo "This workflow must run only on master branch!"
          exit 1

      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Setup .NET 6 to 10 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x
            9.0.x
            10.0.x

      - name: Install dotnet-outdated tool
        run: dotnet tool install --global dotnet-outdated-tool

      - name: Find solution file
        id: find-sln
        run: |
          slnfile=$(find . -maxdepth 1 -name '*.sln' | head -n 1)
          if [[ -z "$slnfile" ]]; then
            echo "No solution file found!"
            exit 1
          fi
          echo "sln=$slnfile" >> $GITHUB_OUTPUT

      - name: Update packages using dotnet-outdated
        run: |
          dotnet outdated "${{ steps.find-sln.outputs.sln }}" --upgrade --no-restore | tee outdated.log

      - name: Update conditional package versions in Directory.Packages.props
        shell: pwsh
        run: |
            $propsPath = "Source/Directory.Packages.props"
            if (!(Test-Path $propsPath)) {
              Write-Host "Directory.Packages.props file not found at $propsPath, skipping step."
              exit 0
            }

            [xml]$props = Get-Content $propsPath

            # Identify .NET versions used in the project
            $usedNetVersions = @()
            foreach ($itemGroup in $props.Project.ItemGroup) {
              if ($itemGroup.Condition) {
                if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                  $usedNetVersions += $Matches[1]
                }
              }
            }

            Write-Host "Detected .NET versions: $($usedNetVersions -join ', ')"

            function IsPreviewVersion {
              param([string]$version)
              return $version -match "-(preview|rc|alpha|beta)"
            }

            function GetVersionParts {
              param([string]$version)
  
              $result = @{
                IsPreview = IsPreviewVersion $version
                Major = 0
                Minor = 0
                Build = 0
                PreviewMajor = 0
                PreviewMinor = 0
                OriginalString = $version
              }
  
              # Handle preview versions with format like "10.0.0-preview.1.25080.5"
              if ($version -match "^(\d+)\.(\d+)\.(\d+)(?:-preview\.(\d+)(?:\.(\d+))?)?$") {
                $result.Major = [int]$Matches[1]
                $result.Minor = [int]$Matches[2]
                $result.Build = [int]$Matches[3]
    
                if ($Matches[4]) {
                  $result.PreviewMajor = [int]$Matches[4]
                  if ($Matches[5]) {
                    $result.PreviewMinor = [int]$Matches[5]
                  }
                }
    
                return $result
              }
  
              # Try standard System.Version parsing as fallback
              try {
                $v = [version]($version -replace '-.*$', '') # Remove preview suffix if any
                $result.Major = $v.Major
                $result.Minor = $v.Minor
                $result.Build = $v.Build
                return $result
              }
              catch {
                Write-Host "Unsupported version format: $version"
                return $result
              }
            }

            function CompareVersions {
              param(
                [string]$version1,
                [string]$version2
              )
  
              $v1 = GetVersionParts $version1
              $v2 = GetVersionParts $version2
  
              # First compare main versions
              if ($v1.Major -ne $v2.Major) { return $v1.Major.CompareTo($v2.Major) }
              if ($v1.Minor -ne $v2.Minor) { return $v1.Minor.CompareTo($v2.Minor) }
              if ($v1.Build -ne $v2.Build) { return $v1.Build.CompareTo($v2.Build) }
  
              # Non-preview versions are always higher than preview versions
              if (!$v1.IsPreview -and $v2.IsPreview) { return 1 }
              if ($v1.IsPreview -and !$v2.IsPreview) { return -1 }
  
              # Compare preview versions
              if ($v1.PreviewMajor -ne $v2.PreviewMajor) { return $v1.PreviewMajor.CompareTo($v2.PreviewMajor) }
              return $v1.PreviewMinor.CompareTo($v2.PreviewMinor)
            }

            function Get-LatestNugetVersionForMajor {
              param(
                [string]$packageId,
                [int]$netMajor,
                [string]$currentVersion
              )
  
              Write-Host "Checking package $packageId for .NET $netMajor (current version: $currentVersion)"
              
              # Sprawdź, czy wersja już odpowiada frameworkowi
              $currentVersionParts = GetVersionParts $currentVersion
              $isCurrentPreview = IsPreviewVersion $currentVersion
              
              # Jeśli to paczka Microsoft, zawsze wymagaj zgodnej głównej wersji
              $isMicrosoftPackage = $packageId -like "Microsoft.AspNetCore.*" -or 
                                    $packageId -like "Microsoft.Extensions.*" -or 
                                    $packageId -like "Microsoft.JSInterop*"
              
              # Jeśli mamy już prawidłową wersję, nie próbuj jej downgrade'ować 
              if ($isMicrosoftPackage -and $currentVersionParts.Major -eq $netMajor) {
                Write-Host "  Current version has correct major version matching .NET $netMajor"
              }
              
              # Adres API NuGet
              $url = "https://api.nuget.org/v3/registration5-semver1/$($packageId.ToLowerInvariant())/index.json"
              try {
                $resp = Invoke-RestMethod -Uri $url -UseBasicParsing
                
                # Pobierz wszystkie dostępne wersje
                $allVersions = @()
                foreach ($item in $resp.items) {
                  foreach ($entry in $item.items) {
                    if ($entry.catalogEntry.version) {
                      $allVersions += $entry.catalogEntry.version
                    }
                  }
                }
                
                Write-Host "  Found $($allVersions.Count) available versions for $packageId"
                
                # Wybierz tylko kompatybilne wersje
                $compatibleVersions = @()
                foreach ($version in $allVersions) {
                  $versionParts = GetVersionParts $version
                  
                  # Dla pakietów Microsoft, wersja główna musi odpowiadać wersji .NET
                  if ($isMicrosoftPackage) {
                    # Major version musi odpowiadać wersji .NET
                    if ($versionParts.Major -ne $netMajor) {
                      Write-Host "  Skipping $version - major version $($versionParts.Major) doesn't match .NET $netMajor"
                      continue
                    }
                  }
                  
                  # Zgodność stabilności (preview vs stable) tylko jeśli zmieniamy wersję
                  # Jeśli aktualna wersja ma inny major niż framework, to pozwalamy zmienić również status preview
                  if ($isMicrosoftPackage -and $currentVersionParts.Major -eq $netMajor) {
                    if ($isCurrentPreview -ne (IsPreviewVersion $version)) {
                      Write-Host "  Skipping $version - preview status doesn't match current version"
                      continue
                    }
                  }
                  
                  # Dla .NET 10, akceptujemy tylko wersje preview
                  if ($netMajor -eq 10) {
                    if (!(IsPreviewVersion $version) -and $version -ne "10.0.0") {
                      Write-Host "  Skipping $version - .NET 10 requires preview versions at this time"
                      continue
                    }
                  }
                  
                  $compatibleVersions += $version
                  Write-Host "  Added compatible version: $version"
                }
                
                if ($compatibleVersions.Count -eq 0) {
                  Write-Host "  No compatible versions found for $packageId with .NET $netMajor. Keeping current version."
                  
                  # Jeśli nie znaleziono kompatybilnej wersji, ale major jest nieprawidłowy dla Microsoft package,
                  # to ustaw domyślną wartość dla danego frameworka
                  if ($isMicrosoftPackage -and $currentVersionParts.Major -ne $netMajor) {
                    if ($netMajor -eq 10) {
                      $defaultVersion = "10.0.0-preview.1.24158.1"
                      Write-Host "  WARNING: Setting default .NET 10 preview version: $defaultVersion"
                      return $defaultVersion
                    } else {
                      $defaultVersion = "$netMajor.0.0"
                      Write-Host "  WARNING: Setting default version for .NET $netMajor: $defaultVersion"
                      return $defaultVersion
                    }
                  }
                  
                  return $currentVersion
                }
                
                # Wybierz najnowszą wersję
                $latestVersion = $null
                $highestCompare = -1
                
                foreach ($ver in $compatibleVersions) {
                  $compareResult = CompareVersions $ver $currentVersion
                  if ($compareResult -gt $highestCompare) {
                    $highestCompare = $compareResult
                    $latestVersion = $ver
                  }
                }
                
                # Tylko aktualizuj do nowszej wersji, nie downgrade'uj jeśli wersja major jest zgodna
                if ($isMicrosoftPackage -and $currentVersionParts.Major -eq $netMajor) {
                  if ($highestCompare -gt 0 -and $latestVersion) {
                    Write-Host "  Found newer version for $packageId - $latestVersion (current: $currentVersion)"
                    return $latestVersion
                  } else {
                    Write-Host "  No newer version found for $packageId (current: $currentVersion)"
                    return $currentVersion
                  }
                } else if ($isMicrosoftPackage -and $currentVersionParts.Major -ne $netMajor) {
                  # Jeśli major jest nieprawidłowy, wymuś aktualizację do latestVersion
                  Write-Host "  Forcing update to version with correct major: $latestVersion (current: $currentVersion)"
                  return $latestVersion
                } else {
                  # Dla nie-Microsoft packages, aktualizuj tylko do nowszej wersji
                  if ($highestCompare -gt 0 -and $latestVersion) {
                    Write-Host "  Found newer version for $packageId - $latestVersion (current: $currentVersion)"
                    return $latestVersion
                  } else {
                    Write-Host "  No newer version found for $packageId (current: $currentVersion)"
                    return $currentVersion
                  }
                }
              }
              catch {
                $errorMessage = $_.Exception.Message
                Write-Host "  Error retrieving versions for $packageId - $errorMessage"
                
                # Alternatywne podejście - użyj API search
                try {
                  Write-Host "  Trying alternative approach with search API..."
                  # Uwzględnij preview dla .NET 10
                  $includePrerelease = ($netMajor -eq 10) -or $isCurrentPreview
                  $searchUrl = "https://azuresearch-usnc.nuget.org/query?q=packageid:$packageId&prerelease=$($includePrerelease.ToString().ToLower())"
                  $searchResp = Invoke-RestMethod -Uri $searchUrl -UseBasicParsing
                  
                  $matchingVersions = @()
                  foreach ($data in $searchResp.data) {
                    if ($data.id -eq $packageId) {
                      foreach ($version in $data.versions) {
                        $versionParts = GetVersionParts $version.version
                        
                        # Dla pakietów Microsoft, sprawdź zgodność głównej wersji
                        if ($isMicrosoftPackage) {
                          if ($versionParts.Major -eq $netMajor) {
                            $matchingVersions += $version.version
                          }
                        }
                        else {
                          $matchingVersions += $version.version
                        }
                      }
                    }
                  }
                  
                  if ($matchingVersions.Count -gt 0) {
                    Write-Host "  Found $($matchingVersions.Count) versions via search API"
                    
                    $latestVersion = $null
                    $highestCompare = -1
                    
                    foreach ($ver in $matchingVersions) {
                      $compareResult = CompareVersions $ver $currentVersion
                      if ($compareResult -gt $highestCompare) {
                        $highestCompare = $compareResult
                        $latestVersion = $ver
                      }
                    }
                    
                    # Zawsze aktualizuj do wersji z poprawnym majorem dla paczek Microsoft
                    if ($isMicrosoftPackage -and $currentVersionParts.Major -ne $netMajor) {
                      Write-Host "  Enforcing update to version with correct major: $latestVersion (current: $currentVersion)"
                      return $latestVersion
                    }
                    
                    # W przeciwnym razie aktualizuj tylko jeśli znaleziono nowszą wersję
                    if ($highestCompare -gt 0 -and $latestVersion) {
                      Write-Host "  Found newer version for $packageId - $latestVersion (current: $currentVersion)"
                      return $latestVersion
                    }
                  }
                }
                catch {
                  $errorMessage2 = $_.Exception.Message
                  Write-Host "  Alternative approach also failed: $errorMessage2"
                }
                
                # Jeśli brak wersji i major jest nieprawidłowy, przyjmij wartość domyślną
                if ($isMicrosoftPackage -and $currentVersionParts.Major -ne $netMajor) {
                  # Dla .NET 10 przyjmij wersję preview
                  if ($netMajor -eq 10) {
                    return "10.0.0-preview.1.24158.1"
                  }
                  # Dla pozostałych przyjmij stabilną wersję
                  return "$netMajor.0.0"
                }
                
                return $currentVersion
              }
            }

            $changes = @()
            $supportedMajors = @(6, 7, 8, 9, 10)

            foreach ($itemGroup in $props.Project.ItemGroup) {
              if ($itemGroup.Condition) {
                if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                  $netMajor = [int]$Matches[1]
      
                  if ($supportedMajors -contains $netMajor) {
                    Write-Host "Processing packages for .NET $netMajor..."
                    Write-Host "Condition: $($itemGroup.Condition)"
        
                    foreach ($pkg in $itemGroup.PackageVersion) {
                      $id = $pkg.Include
                      $current = $pkg.Version
          
                      Write-Host "Checking package: $id ($current) for .NET $netMajor"
          
                      # Dodajmy specjalną obsługę dla pakietów Microsoft
                      # Upewnijmy się, że pakiety Microsoft mają zawsze zgodną główną wersję
                      if (($id -like "Microsoft.AspNetCore.*" -or 
                           $id -like "Microsoft.Extensions.*" -or 
                           $id -like "Microsoft.JSInterop*") -and 
                           ([int](GetVersionParts $current).Major) -ne $netMajor) {
                           
                        # Wymuszamy prawidłową wersję dla krytycznych pakietów Microsoft
                        Write-Host "  WARNING: Package $id has incorrect major version (current: $current, should be $netMajor.x)!"
                        
                        # Spróbuj znaleźć najnowszą poprawną wersję dla tego frameworka
                        $latest = Get-LatestNugetVersionForMajor -packageId $id -netMajor $netMajor -currentVersion "$netMajor.0.0"
                        
                        if ($latest -ne "$netMajor.0.0") {
                          Write-Host "  Forcing update of $id (net$netMajor.0): $current -> $latest (major version mismatch fix)"
                          $pkg.Version = $latest
                          $changes += "$id (net$netMajor.0): $current -> $latest (fixed major version)"
                          continue
                        }
                      }
          
                      # Standardowa aktualizacja do najnowszej wersji
                      $latest = Get-LatestNugetVersionForMajor -packageId $id -netMajor $netMajor -currentVersion $current
          
                      if ($latest -and $current -ne $latest) {
                        Write-Host "  Updating $id (net$netMajor.0): $current -> $latest"
                        $pkg.Version = $latest
                        $changes += "$id (net$netMajor.0): $current -> $latest"
                      }
                    }
                  } else {
                    Write-Host "Skipped unsupported .NET version $netMajor"
                  }
                }
              }
            }

            # Dodaj tę sekcję przed zapisem zmian
            Write-Host "Performing final validation of package versions..."
            $validationIssues = @()

            foreach ($itemGroup in $props.Project.ItemGroup) {
              if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                $netMajor = [int]$Matches[1]
                
                foreach ($pkg in $itemGroup.PackageVersion) {
                  $id = $pkg.Include
                  $version = $pkg.Version
                  $versionParts = GetVersionParts $version
                  
                  # Sprawdź, czy krytyczne pakiety Microsoft mają zgodne wersje
                  if (($id -like "Microsoft.AspNetCore.*" -or 
                       $id -like "Microsoft.Extensions.*" -or 
                       $id -like "Microsoft.JSInterop*") -and 
                       $versionParts.Major -ne $netMajor) {
                    
                    $validationIssues += "ERROR: $id for .NET $netMajor has incorrect version $version"
                    
                    # Napraw wersję, jeśli to możliwe
                    $correctVersion = Get-LatestNugetVersionForMajor -packageId $id -netMajor $netMajor -currentVersion "$netMajor.0.0"
                    if ($correctVersion -ne "$netMajor.0.0") {
                      Write-Host "  FIXING: Update $id to $correctVersion (from $version)"
                      $pkg.Version = $correctVersion
                      $changes += "$id (net$netMajor.0): $version -> $correctVersion (validation fix)"
                    } else {
                      Write-Host "  UNABLE TO FIX: No valid version found for $id (.NET $netMajor)"
                    }
                  }
                }
              }
            }

            if ($validationIssues.Count -gt 0) {
              Write-Host "Validation issues found:"
              foreach ($issue in $validationIssues) {
                Write-Host "  $issue"
              }
              Write-Host "Attempted to fix issues automatically."
            }

            if ($changes.Count -gt 0) {
              $props.Save($propsPath)
              Set-Content -Path conditional-updates.log -Value ($changes -join "`n")
              Write-Host "Updated conditional package versions."
            } else {
              Write-Host "No changes to conditional package versions."
              Set-Content -Path conditional-updates.log -Value ""
            }

      - name: Check for changes
        id: git-check
        run: |
          if [[ -z "$(git status --porcelain)" ]]; then
            echo "No changes to commit"
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Ensure "automated-task" label exists
        if: steps.git-check.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh_label_exists=$(gh api repos/${{ github.repository }}/labels/automated-task --silent 2>/dev/null || echo "404")
          if [[ "$gh_label_exists" == "404" ]]; then
            gh api repos/${{ github.repository }}/labels \
              -X POST \
              -F name='automated-task' \
              -F color='ededed' \
              -F description='PR generated by NuGet update workflow'
          fi

      - name: Prepare PR body with list of updated packages
        id: pr-body
        if: steps.git-check.outputs.changed == 'true'
        run: |
          changes=$(grep -E ' -> ' outdated.log | grep -vE '^\s*$|^\[' | awk '{$1=$1};1' | sort | uniq)
          cond_changes=$(cat conditional-updates.log)
          BODY=""
          
          if [[ -n "$changes" ]]; then
              BODY="### The following NuGet packages were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk '{print $1}')
                  from=$(echo "$line" | awk '{print $2}')
                  to=$(echo "$line" | awk '{print $4}')
                  BODY+="
          - **$name**: \`$from\` ~~→~~ \`$to\`"
              done <<< "$changes"
          fi
          
          if [[ -n "$cond_changes" ]]; then
              BODY+="
          ### The following conditional NuGet package versions were updated:"
              while IFS= read -r line; do
                  name=$(echo "$line" | awk -F':' '{print $1}')
                  fromto=$(echo "$line" | awk -F':' '{print $2}')
                  BODY+="
          - **$name**: $fromto"
              done <<< "$cond_changes"
          fi
          
          if [[ -z "$BODY" ]]; then
              BODY="NuGet run did not output package updates, but there are file changes."
          fi
          
          BODY="${BODY//'%'/'%25'}"
          echo "body<<EOF" >> $GITHUB_OUTPUT
          echo "$BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.git-check.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          title: "[Task] Automated NuGet package update"
          commit-message: "[Task] Automated NuGet package update"
          branch: auto/update-nuget-packages
          base: master
          delete-branch: true
          labels: automated-task
          body: ${{ steps.pr-body.outputs.body }}