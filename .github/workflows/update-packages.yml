name: Update NuGet Packages

on:
  workflow_dispatch:

jobs:
  update-packages:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Fail if not on master
        if: github.ref != 'refs/heads/master'
        run: |
          echo "This workflow must run only on master branch!"
          exit 1

      - name: Checkout master
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Setup .NET 6 to 10 SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x
            9.0.x
            10.0.x

      - name: Install dotnet-outdated tool
        run: dotnet tool install --global dotnet-outdated-tool

      - name: Find solution file
        id: find-sln
        run: |
          slnfile=$(find . -maxdepth 1 -name '*.sln' | head -n 1)
          if [[ -z "$slnfile" ]]; then
            echo "No solution file found!"
            exit 1
          fi
          echo "sln=$slnfile" >> $GITHUB_OUTPUT

      - name: Update packages using dotnet-outdated
        run: |
          dotnet outdated "${{ steps.find-sln.outputs.sln }}" --upgrade --no-restore | tee outdated.log

      - name: Update conditional package versions in Directory.Packages.props
        shell: pwsh
        run: |
          $propsPath = "Source/Directory.Packages.props"
          if (!(Test-Path $propsPath)) {
            Write-Host "Brak pliku $propsPath, pomijam krok."
            exit 0
          }
          
          [xml]$props = Get-Content $propsPath
          
          # Sprawdzamy wersje .NET używane w projekcie
          $usedNetVersions = @()
          foreach ($itemGroup in $props.Project.ItemGroup) {
            if ($itemGroup.Condition) {
              if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                $usedNetVersions += $Matches[1]
              }
            }
          }
          
          Write-Host "Wykryto wersje .NET: $($usedNetVersions -join ', ')"
          
          function Compare-NuGetVersions {
            param (
              [string]$version1,
              [string]$version2
            )
            
            # Funkcja do porównywania wersji z obsługą preview
            function Parse-Version {
              param([string]$version)
              
              if ($version -match "^(\d+\.\d+\.\d+)(?:-preview\.(\d+)(?:\.(\d+))?)?$") {
                $mainVer = [version]$Matches[1]
                $previewNum1 = if ($Matches[2]) { [int]$Matches[2] } else { 0 }
                $previewNum2 = if ($Matches[3]) { [int]$Matches[3] } else { 0 }
                
                return @{
                  IsPreview = $version -match "-preview"
                  Major = $mainVer.Major
                  Minor = $mainVer.Minor
                  Build = $mainVer.Build
                  PreviewMajor = $previewNum1
                  PreviewMinor = $previewNum2
                }
              }
              else {
                try {
                  $v = [version]$version
                  return @{
                    IsPreview = $false
                    Major = $v.Major
                    Minor = $v.Minor
                    Build = $v.Build
                    PreviewMajor = 0
                    PreviewMinor = 0
                  }
                }
                catch {
                  Write-Host "Nieobsługiwany format wersji: $version"
                  return $null
                }
              }
            }
            
            $v1 = Parse-Version $version1
            $v2 = Parse-Version $version2
            
            if ($null -eq $v1 -or $null -eq $v2) {
              return 0  # Nie można porównać
            }
            
            # Najpierw porównaj główne wersje
            if ($v1.Major -ne $v2.Major) { return $v1.Major.CompareTo($v2.Major) }
            if ($v1.Minor -ne $v2.Minor) { return $v1.Minor.CompareTo($v2.Minor) }
            if ($v1.Build -ne $v2.Build) { return $v1.Build.CompareTo($v2.Build) }
            
            # Wersje bez preview są zawsze większe niż wersje preview
            if (!$v1.IsPreview -and $v2.IsPreview) { return 1 }
            if ($v1.IsPreview -and !$v2.IsPreview) { return -1 }
            
            # Teraz porównujemy wersje preview
            if ($v1.PreviewMajor -ne $v2.PreviewMajor) { return $v1.PreviewMajor.CompareTo($v2.PreviewMajor) }
            return $v1.PreviewMinor.CompareTo($v2.PreviewMinor)
          }
          
          function Get-LatestNugetVersionForMajor {
            param(
              [string]$packageId,
              [string]$major,
              [string]$currentVersion
            )
            
            $url = "https://api.nuget.org/v3-flatcontainer/$packageId/index.json"
            try {
              $resp = Invoke-RestMethod -Uri $url -UseBasicParsing
              
              $isCurrentPreview = $currentVersion -match "-preview"
              $mainVersionPrefix = "$major\."

              # Ograniczamy wersje do tego samego major release
              $versions = $resp.versions | Where-Object { $_ -match "^$mainVersionPrefix" }
              
              if (!$versions) {
                Write-Host "Brak wersji dla pakietu $packageId zaczynających się od $major."
                return $currentVersion
              }
              
              $availableVersions = @()
              if ($isCurrentPreview) {
                # Dla preview, znajdź tylko nowsze wersje preview z tego samego major
                $previewVersions = $versions | Where-Object { $_ -match "-preview" }
                $availableVersions = $previewVersions
                Write-Host "Obecna wersja $packageId to preview: $currentVersion. Znaleziono $(($previewVersions | Measure-Object).Count) wersji preview."
              } else {
                # Dla stabilnych, znajdź tylko nowsze stabilne wersje z tego samego major
                $stableVersions = $versions | Where-Object { $_ -notmatch "-preview" }
                $availableVersions = $stableVersions
                Write-Host "Obecna wersja $packageId to stabilna: $currentVersion. Znaleziono $(($stableVersions | Measure-Object).Count) wersji stabilnych."
              }
              
              if ($availableVersions.Count -eq 0) {
                Write-Host "Brak odpowiednich wersji dla $packageId. Zachowuję obecną."
                return $currentVersion
              }
              
              # Sortowanie z użyciem naszej własnej funkcji porównującej wersje
              $sortedVersions = $availableVersions | Sort-Object -Property { $_ } -Descending {
                param($a, $b)
                return Compare-NuGetVersions $a $b
              }
              
              $latestVersion = $sortedVersions[0]
              
              # Sprawdź czy znaleziona wersja jest nowsza
              if ((Compare-NuGetVersions $latestVersion $currentVersion) -gt 0) {
                Write-Host "Znaleziono nowszą wersję dla $packageId: $latestVersion (obecna: $currentVersion)"
                return $latestVersion
              } else {
                Write-Host "Nie znaleziono nowszej wersji dla $packageId (obecna: $currentVersion)"
                return $currentVersion
              }
            }
            catch {
              $errorMessage = $_.Exception.Message
              Write-Host "Błąd podczas pobierania wersji dla $packageId: $errorMessage"
              return $currentVersion
            }
          }
          
          $changes = @()
          $supportedMajors = @(6, 7, 8, 9, 10)
          
          foreach ($itemGroup in $props.Project.ItemGroup) {
            if ($itemGroup.Condition) {
              if ($itemGroup.Condition -match "'\$\((?:TargetFramework|TargetFrameworkIdentifier)\)' *== *'net(\d+)\.0'") {
                $major = $Matches[1]
                
                if ($supportedMajors -contains [int]$major) {
                  Write-Host "Przet